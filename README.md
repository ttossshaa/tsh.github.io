# tsh.github.io
лабораторная работа 1
### Цель работы  
1. Реализовать алгоритм вычисления вероятности появления потомства с доминантным фенотипом.  
2. Применить принципы объектно-ориентированного программирования для структурирования кода.  
3. Обеспечить гибкость ввода данных (ручной/автоматический).  

---

### Задачи  
- Спроектировать класс `GenotypeCalculator`, инкапсулирующий данные о популяции.  
- Реализовать два режима ввода: генерация случайных данных и ручной ввод.  
- Рассчитать вероятность доминирования для всех возможных пар организмов.  
- Обеспечить вывод результата с плавающей точкой.  

---

### Шаги реализации  
#### 1. Класс `GenotypeCalculator`  
```python  
class GenotypeCalculator:
    def __init__(self):
        self.k = 0  # AA
        self.m = 0  # Aa
        self.n = 0  # aa

    def generate_numbers(self):
        self.k = random.randint(1, 100)
        self.m = random.randint(1, 100)
        self.n = random.randint(1, 100)
        print(f"Сгенерированные числа - AA: {self.k}, Aa: {self.m}, aa: {self.n}")

    def input_numbers(self):
        self.k = int(input("Введите число для AA: "))
        self.m = int(input("Введите число для Aa: "))
        self.n = int(input("Введите число для aa: "))

    def probability(self):
        total = self.k + self.m + self.n
        possible_pairs = total * (total - 1) / 2
        
        dominant_pairs = (
            (self.k * (self.k - 1)) / 2 +          # AA x AA
            self.k * self.m +                     # AA x Aa
            self.k * self.n +                     # AA x aa
            (self.m * (self.m - 1)) / 2 * 0.75 +  # Aa x Aa
            self.m * self.n * 0.5                 # Aa x aa
        )
        
        probability = dominant_pairs / possible_pairs if possible_pairs > 0 else 0
        print(f"Вероятность: {probability:.5f}")
```

#### 2. Основная программа  
```python  
def main():
    calculator = GenotypeCalculator()
    print('g - генерация числа, i - ввод с клавиатуры')
    choice = input()
    if choice == 'g':
        calculator.generate_numbers()
    elif choice == 'i':
        calculator.input_numbers()
    else:
        print('Ошибка')
        return  
    calculator.probability()
```

---

### Пример работы программы  
**Входные данные (генерация):**  
```
Сгенерированные числа - AA: 32, Aa: 18, aa: 36  
```
**Вывод:**  
```
Вероятность: 0.72852  
```

**Входные данные (ручной ввод):**  
```
AA: 1  
Aa: 0  
aa: 1  
```
**Вывод:**  
```
Вероятность: 0.00000  
```

---

### Принципы ООП в решении  
1. **Инкапсуляция:**  
   - Данные популяции (k, m, n) и методы работы с ними объединены в классе.  
   - Логика расчёта изолирована в методе `probability()`.  

2. **Полиморфизм:**  
   - Реализованы альтернативные способы инициализации данных (генерация/ручной ввод).  

3. **Расширяемость:**  
   - Легко добавить новые типы организмов или изменить вероятности доминирования.  
   - Возможно внедрение дополнительных проверок входных данных.  

---

### Заключение  
Разработанная программа соответствует принципам ООП:  
- **Читаемость:** Чёткое разделение на методы с говорящими названиями.  
- **Гибкость:** Поддержка двух режимов ввода данных.  
- **Надёжность:** Обработка крайних случаев (например, нулевое количество пар).

лабораторная работа 2  
## **1. Цель работы**  
- Реализовать алгоритм для поиска всех позиций вхождения подстроки в строку.  
- Обеспечить удобный ввод данных и вывод результатов.  

## **2. Задачи**  
1. Написать функцию `find_substring_positions`, которая находит все стартовые позиции подстроки `t` в строке `s`.  
2. Организовать ввод строки `s` и подстроки `t` с клавиатуры.  
3. Вывести найденные позиции в удобочитаемом формате.  

## **3. Реализация**  

### **3.1. Функция `find_substring_positions`**  
```python
def find_substring_positions(s, t):
    positions = []  # Список для хранения позиций вхождения
    for i in range(len(s) - len(t) + 1):  # Проход по всем возможным стартовым позициям
        if s[i:i+len(t)] == t:  # Проверка совпадения подстроки
            positions.append(i)  # Добавление позиции в список
    return positions
```

### **3.2. Основная программа**  
```python
s = input("Введите строку s (ДНК): ")
t = input("Введите строку t (подстрока): ")
positions = find_substring_positions(s, t)
print(" ".join(map(str, positions)))  # Преобразование списка в строку с разделителем
```

### **3.3. Пример работы**  
**Входные данные:**  
```
Введите строку s (ДНК): GATATATGCATATACTT  
Введите строку t (подстрока): ATAT  
```  
**Вывод:**  
```
1 3 9
```  

## **4. Принципы программирования в решении**  

### **4.1. Простота и ясность**  
- Алгоритм использует простой перебор всех возможных позиций.  
- Код легко читается и понимается.  

### **4.2. Эффективность**  
- Время работы алгоритма — O(n*m), где n — длина строки `s`, m — длина подстроки `t`.  
- Для небольших строк (например, последовательностей ДНК) этого достаточно.  

### **4.3. Удобство ввода-вывода**  
- Ввод данных организован интерактивно.  
- Результат выводится в виде чисел, разделенных пробелами.  

## **5. Заключение**  
- Программа успешно решает поставленную задачу.  
- Алгоритм корректен и работает для стандартных случаев.  
- Код прост, понятен и может быть легко модифицирован.  

лабораторная работа 3.1
## **1. Цель работы**  
- Изучить набор данных Iris и его структуру.  
- Реализовать визуализацию данных с помощью диаграмм рассеяния.  
- Применить объектно-ориентированный подход для организации кода.  

## **2. Задачи**  
1. Загрузить набор данных Iris.  
2. Создать класс `IrisScatterPlot` для работы с данными и их визуализации.  
3. Реализовать выбор признаков для осей X и Y.  
4. Построить диаграмму рассеяния с цветовой дифференциацией по классам.  
5. Настроить оформление графика (названия осей, легенду, сетку).  

## **3. Реализация**  

### **3.1. Класс `IrisScatterPlot`**  
```python
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
import pandas as pd

class IrisScatterPlot:
    def __init__(self):
        """Инициализация с загрузкой данных Iris."""
        self.data = load_iris()
        self.df = pd.DataFrame(self.data.data, columns=self.data.feature_names)
        self.df['target'] = self.data.target

    def get_factors(self, factor_x, factor_y):
        """Получение данных для построения графика."""
        x = self.df[factor_x]
        y = self.df[factor_y]
        classes = self.df['target']
        return x, y, classes

    def plot_scatter(self, factor_x, factor_y):
        """Построение диаграммы рассеяния."""
        x, y, classes = self.get_factors(factor_x, factor_y)

        plt.figure(figsize=(10, 6))
        for class_value in classes.unique():
            plt.scatter(
                x[classes == class_value],
                y[classes == class_value],
                label=self.data.target_names[class_value]
            )

        plt.title('Диаграмма рассеяния: {} vs {}'.format(factor_x, factor_y))
        plt.xlabel(factor_x)
        plt.ylabel(factor_y)
        plt.legend(title="Классы")
        plt.grid(True)
        plt.show()
```

### **3.2. Основная программа**  
```python
if __name__ == "__main__":
    scatter_plot = IrisScatterPlot()
    scatter_plot.plot_scatter('sepal length (cm)', 'sepal width (cm)')
```

## **3. Принципы ООП и анализа данных**  

### **3.1. Инкапсуляция**  
- Данные (`data`, `df`) и методы работы с ними (`get_factors`, `plot_scatter`) объединены в классе.  

### **3.2. Гибкость**  
- Можно легко изменить признаки для осей X и Y, например:  
  ```python
  scatter_plot.plot_scatter('petal length (cm)', 'petal width (cm)')
  ```  

### **3.3. Визуализация**  
- Использована библиотека `matplotlib` для построения графиков.  
- Настройки оформления (заголовок, подписи осей, легенда, сетка) улучшают читаемость.  

## **4. Заключение**  
- Программа успешно визуализирует данные Iris с помощью диаграмм рассеяния.  
- Применен объектно-ориентированный подход для структурирования кода.  
- Решение легко расширяется для анализа других признаков или наборов данных.  

лабораторная работа 3.2
## **1. Цель работы**  
- Изучить временные ряды данных концентрации CO₂ в атмосфере.  
- Реализовать загрузку, фильтрацию и визуализацию данных.  
- Применить объектно-ориентированный подход для организации кода.  

## **2. Задачи**  
1. Загрузить набор данных CO₂ из библиотеки statsmodels.  
2. Создать класс `TimeSeriesPlot` для обработки и визуализации данных.  
3. Реализовать фильтрацию данных по заданному временному промежутку.  
4. Построить график динамики уровня CO₂ с настройкой оформления.  

## **3. Реализация**  

### **3.1. Класс `TimeSeriesPlot`**  
```python
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt

class TimeSeriesPlot:
    def __init__(self, dataset_name, start_year, end_year):
        """Инициализация с параметрами загрузки данных."""
        self.dataset_name = dataset_name
        self.start_year = start_year
        self.end_year = end_year
        self.data = self.load_data()

    def load_data(self):
        """Загрузка данных CO₂ и преобразование индекса."""
        data = sm.datasets.co2.load_pandas().data
        data.index = pd.to_datetime(data.index)  # Преобразование в datetime
        return data

    def filter_data(self):
        """Фильтрация данных по заданному временному промежутку."""
        return self.data[(self.data.index.year >= self.start_year) & 
                        (self.data.index.year <= self.end_year)]

    def plot_time_series(self):
        """Построение графика временного ряда."""
        filtered_data = self.filter_data()
        
        plt.figure(figsize=(12, 6))
        plt.plot(filtered_data.index, filtered_data['co2'], 
                label='CO2 Levels', color='blue')
        
        plt.title(f'Динамика уровня CO2 ({self.start_year}-{self.end_year})')
        plt.xlabel('Годы')
        plt.ylabel('Уровень CO2')
        plt.legend()
        plt.grid(True)
        plt.show()
```

### **3.2. Основная программа**  
```python
if __name__ == "__main__":
    co2_plot = TimeSeriesPlot(dataset_name='co2', start_year=1958, end_year=1980)
    co2_plot.plot_time_series()
```
## **4. Принципы ООП и анализа данных**  

### **4.1. Инкапсуляция**  
- Данные (`data`) и методы (`load_data`, `filter_data`, `plot_time_series`) инкапсулированы в классе.  

### **4.2. Гибкость**  
- Можно изменить временной промежуток:  
  ```python
  co2_plot = TimeSeriesPlot('co2', 1990, 2020)
  ```  

### **4.3. Визуализация**  
- Использована библиотека `matplotlib` для построения графиков.  
- Настройки оформления улучшают восприятие данных.  

## **5. Заключение**  
- Программа успешно загружает, фильтрует и визуализирует данные CO₂.  
- Объектно-ориентированный подход упрощает расширение функционала.  
- Решение может быть адаптировано для других временных рядов.  

лабораторная работа 4.1
# **Отчет по лабораторной работе**  
**Тема:** Анализ GC-состава геномных последовательностей  

## **1. Цель работы**  
- Изучить структуру GenBank файлов и методы работы с ними в Python.  
- Реализовать расчет GC-состава (доли гуанина и цитозина) для геномных последовательностей.  
- Разработать алгоритм сортировки записей по GC-составу.  

## **2. Задачи**  
1. Реализовать функцию расчета GC-состава для последовательности ДНК.  
2. Написать функцию парсинга GenBank файла и извлечения последовательностей.  
3. Сортировать записи по значению GC-состава.  
4. Вывести результаты в удобочитаемом формате.  

## **3. Реализация**  

### **3.1. Функция расчета GC-состава**  
```python
def calculate_gc_content(sequence):
    """Вычисляет долю GC-оснований в последовательности ДНК."""
    gc_count = sequence.count('G') + sequence.count('C')
    return gc_count / len(sequence) if len(sequence) > 0 else 0
```

### **3.2. Функция обработки GenBank файла**  
```python
from Bio import SeqIO

def sort_records_by_gc(gb_file):
    """Сортирует записи GenBank файла по GC-составу."""
    records = []
    for record in SeqIO.parse(gb_file, "genbank"):
        sequence = str(record.seq).upper()  # Нормализация регистра
        gc_content = calculate_gc_content(sequence)
        records.append((record, gc_content))
    
    # Сортировка по возрастанию GC-состава
    records.sort(key=lambda x: x[1])
    
    # Вывод результатов
    for record, gc_content in records:
        print(f"{record.id}: {record.description[:50]}..., GC = {gc_content:.3f}")
```

## **4. Анализ кода**  

### **4.1. Библиотека Biopython**  
- Использован модуль `Bio.SeqIO` для чтения GenBank файлов.  
- Метод `SeqIO.parse()` обеспечивает итерацию по записям в файле.  

### **4.2. Особенности реализации**  
1. **Нормализация регистра:**  
   `str(record.seq).upper()` гарантирует корректный подсчет оснований.  

2. **Обработка пустых последовательностей:**  
   Проверка `len(sequence) > 0` предотвращает деление на ноль.  

3. **Форматирование вывода:**  
   Обрезание длинных описаний (`description[:50]`) улучшает читаемость.  

## **5. Заключение**  
- Программа успешно анализирует GC-состав последовательностей из GenBank файлов.  
- Реализована сортировка записей по геномному параметру.  
- Код может быть расширен для:  
  - анализа других характеристик (кодирующих регионов, повторов);  
  - сохранения результатов в файл;
  - визуализации распределения GC-состава.

лабораторная работа 4.2
## **1. Цель работы**  
- Изучить структуру GenBank файлов и особенности аннотации кодирующих последовательностей (CDS)  
- Реализовать алгоритм трансляции нуклеотидных последовательностей в аминокислотные  
- Разработать программу для извлечения и анализа белковых последовательностей из геномных данных  

## **2. Задачи**  
1. Реализовать функцию для трансляции CDS с учетом ориентации гена  
2. Обрабатывать особенности GenBank формата (местоположение генов, strand-специфичность)  
3. Организовать вывод информации о транслированных последовательностях  
4. Обеспечить обработку ошибок трансляции  

## **3. Реализация**  

### **3.1. Функция трансляции CDS**  
```python
def translate_cds(record, feature):
    """Транслирует кодирующую последовательность в белковую"""
    if feature.type == "CDS":
        # Извлечение координат и ориентации гена
        start = feature.location.start
        end = feature.location.end
        strand = feature.location.strand  # 1 для прямой цепи, -1 для обратной
        
        # Получение кодирующей последовательности
        if strand == 1:
            coding_seq = record.seq[start:end]
        else:
            coding_seq = record.seq[start:end].reverse_complement()
        
        # Трансляция с остановкой на стоп-кодоне
        try:
            protein_seq = str(coding_seq.translate(to_stop=True))
            return protein_seq, start, end, strand
        except Exception as e:
            print(f"Ошибка трансляции CDS в {record.id}: {e}")
            return None, None, None, None
    return None, None, None, None
```

### **3.2. Обработка GenBank файла**  
```python
def process_genbank_file(gb_file):
    """Основная функция обработки файла"""
    translations = []  # Список для хранения результатов
    
    for record in SeqIO.parse(gb_file, "genbank"):
        for feature in record.features:
            protein_seq, start, end, strand = translate_cds(record, feature)
            if protein_seq:  # Если трансляция успешна
                translations.append((
                    record, feature, protein_seq, 
                    start, end, strand
                ))
    
    # Вывод результатов
    print("Результаты трансляции CDS:")
    for item in translations:
        record, feature, protein_seq, start, end, strand = item
        print(f"\nЗапись: {record.id}: {record.description[:50]}...")
        print(f"Позиция CDS: [{start+1}:{end}] ({'Прямая' if strand == 1 else 'Обратная'} цепь)")
        print(f"Белок ({len(protein_seq)} а.о.):\n{protein_seq}")
```

## **4. Анализ кода**  

### **4.1. Особенности реализации**  
1. **Обработка ориентации гена:**  
   - Для генов на обратной цепи выполняется reverse_complement()  
   - Учитывается strand (1 или -1) из feature.location  

2. **Трансляция:**  
   - Параметр to_stop=True останавливает трансляцию на первом стоп-кодоне  
   - Обработка исключений для проблемных последовательностей  

3. **Вывод информации:**  
   - Отображение положения CDS в 1-индексированном формате  
   - Указание длины белковой последовательности  

### **4.2. Используемые библиотеки**  
- **Bio.SeqIO**: для чтения GenBank файлов  
- **Bio.Seq**: для операций с последовательностями (reverse_complement, translate)  

## **5. Заключение**  
- Программа успешно извлекает и транслирует кодирующие последовательности  
- Реализована корректная обработка особенностей геномной аннотации  
- Код может быть расширен для:  
  - анализа доменной структуры белков  
  - сравнения ортологичных генов  
  - предсказания вторичной структуры  





