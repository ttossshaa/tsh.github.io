# tsh.github.io
лабораторная работа 1
### Цель работы  
1. Реализовать алгоритм вычисления вероятности появления потомства с доминантным фенотипом.  
2. Применить принципы объектно-ориентированного программирования для структурирования кода.  
3. Обеспечить гибкость ввода данных (ручной/автоматический).  

---

### Задачи  
- Спроектировать класс `GenotypeCalculator`, инкапсулирующий данные о популяции.  
- Реализовать два режима ввода: генерация случайных данных и ручной ввод.  
- Рассчитать вероятность доминирования для всех возможных пар организмов.  
- Обеспечить вывод результата с плавающей точкой.  

---

### Шаги реализации  
#### 1. Класс `GenotypeCalculator`  
```python  
class GenotypeCalculator:
    def __init__(self):
        self.k = 0  # AA
        self.m = 0  # Aa
        self.n = 0  # aa

    def generate_numbers(self):
        self.k = random.randint(1, 100)
        self.m = random.randint(1, 100)
        self.n = random.randint(1, 100)
        print(f"Сгенерированные числа - AA: {self.k}, Aa: {self.m}, aa: {self.n}")

    def input_numbers(self):
        self.k = int(input("Введите число для AA: "))
        self.m = int(input("Введите число для Aa: "))
        self.n = int(input("Введите число для aa: "))

    def probability(self):
        total = self.k + self.m + self.n
        possible_pairs = total * (total - 1) / 2
        
        dominant_pairs = (
            (self.k * (self.k - 1)) / 2 +          # AA x AA
            self.k * self.m +                     # AA x Aa
            self.k * self.n +                     # AA x aa
            (self.m * (self.m - 1)) / 2 * 0.75 +  # Aa x Aa
            self.m * self.n * 0.5                 # Aa x aa
        )
        
        probability = dominant_pairs / possible_pairs if possible_pairs > 0 else 0
        print(f"Вероятность: {probability:.5f}")
```

#### 2. Основная программа  
```python  
def main():
    calculator = GenotypeCalculator()
    print('g - генерация числа, i - ввод с клавиатуры')
    choice = input()
    if choice == 'g':
        calculator.generate_numbers()
    elif choice == 'i':
        calculator.input_numbers()
    else:
        print('Ошибка')
        return  
    calculator.probability()
```

---

### Пример работы программы  
**Входные данные (генерация):**  
```
Сгенерированные числа - AA: 32, Aa: 18, aa: 36  
```
**Вывод:**  
```
Вероятность: 0.72852  
```

**Входные данные (ручной ввод):**  
```
AA: 1  
Aa: 0  
aa: 1  
```
**Вывод:**  
```
Вероятность: 0.00000  
```

---

### Принципы ООП в решении  
1. **Инкапсуляция:**  
   - Данные популяции (k, m, n) и методы работы с ними объединены в классе.  
   - Логика расчёта изолирована в методе `probability()`.  

2. **Полиморфизм:**  
   - Реализованы альтернативные способы инициализации данных (генерация/ручной ввод).  

3. **Расширяемость:**  
   - Легко добавить новые типы организмов или изменить вероятности доминирования.  
   - Возможно внедрение дополнительных проверок входных данных.  

---

### Заключение  
Разработанная программа соответствует принципам ООП:  
- **Читаемость:** Чёткое разделение на методы с говорящими названиями.  
- **Гибкость:** Поддержка двух режимов ввода данных.  
- **Надёжность:** Обработка крайних случаев (например, нулевое количество пар).

лабораторная работа 2  
## **1. Цель работы**  
- Реализовать алгоритм для поиска всех позиций вхождения подстроки в строку.  
- Обеспечить удобный ввод данных и вывод результатов.  

## **2. Задачи**  
1. Написать функцию `find_substring_positions`, которая находит все стартовые позиции подстроки `t` в строке `s`.  
2. Организовать ввод строки `s` и подстроки `t` с клавиатуры.  
3. Вывести найденные позиции в удобочитаемом формате.  

## **3. Реализация**  

### **3.1. Функция `find_substring_positions`**  
```python
def find_substring_positions(s, t):
    positions = []  # Список для хранения позиций вхождения
    for i in range(len(s) - len(t) + 1):  # Проход по всем возможным стартовым позициям
        if s[i:i+len(t)] == t:  # Проверка совпадения подстроки
            positions.append(i)  # Добавление позиции в список
    return positions
```

### **3.2. Основная программа**  
```python
s = input("Введите строку s (ДНК): ")
t = input("Введите строку t (подстрока): ")
positions = find_substring_positions(s, t)
print(" ".join(map(str, positions)))  # Преобразование списка в строку с разделителем
```

### **3.3. Пример работы**  
**Входные данные:**  
```
Введите строку s (ДНК): GATATATGCATATACTT  
Введите строку t (подстрока): ATAT  
```  
**Вывод:**  
```
1 3 9
```  

## **4. Принципы программирования в решении**  

### **4.1. Простота и ясность**  
- Алгоритм использует простой перебор всех возможных позиций.  
- Код легко читается и понимается.  

### **4.2. Эффективность**  
- Время работы алгоритма — O(n*m), где n — длина строки `s`, m — длина подстроки `t`.  
- Для небольших строк (например, последовательностей ДНК) этого достаточно.  

### **4.3. Удобство ввода-вывода**  
- Ввод данных организован интерактивно.  
- Результат выводится в виде чисел, разделенных пробелами.  

## **5. Заключение**  
- Программа успешно решает поставленную задачу.  
- Алгоритм корректен и работает для стандартных случаев.  
- Код прост, понятен и может быть легко модифицирован.  
  
