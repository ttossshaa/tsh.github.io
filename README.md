# tsh.github.io
лабораторная работа 1
### Цель работы  
1. Реализовать алгоритм вычисления вероятности появления потомства с доминантным фенотипом.  
2. Применить принципы объектно-ориентированного программирования для структурирования кода.  
3. Обеспечить гибкость ввода данных (ручной/автоматический).  

---

### Задачи  
- Спроектировать класс `GenotypeCalculator`, инкапсулирующий данные о популяции.  
- Реализовать два режима ввода: генерация случайных данных и ручной ввод.  
- Рассчитать вероятность доминирования для всех возможных пар организмов.  
- Обеспечить вывод результата с плавающей точкой.  

---

### Шаги реализации  
#### 1. Класс `GenotypeCalculator`  
```python  
class GenotypeCalculator:
    def __init__(self):
        self.k = 0  # AA
        self.m = 0  # Aa
        self.n = 0  # aa

    def generate_numbers(self):
        self.k = random.randint(1, 100)
        self.m = random.randint(1, 100)
        self.n = random.randint(1, 100)
        print(f"Сгенерированные числа - AA: {self.k}, Aa: {self.m}, aa: {self.n}")

    def input_numbers(self):
        self.k = int(input("Введите число для AA: "))
        self.m = int(input("Введите число для Aa: "))
        self.n = int(input("Введите число для aa: "))

    def probability(self):
        total = self.k + self.m + self.n
        possible_pairs = total * (total - 1) / 2
        
        dominant_pairs = (
            (self.k * (self.k - 1)) / 2 +          # AA x AA
            self.k * self.m +                     # AA x Aa
            self.k * self.n +                     # AA x aa
            (self.m * (self.m - 1)) / 2 * 0.75 +  # Aa x Aa
            self.m * self.n * 0.5                 # Aa x aa
        )
        
        probability = dominant_pairs / possible_pairs if possible_pairs > 0 else 0
        print(f"Вероятность: {probability:.5f}")
```

#### 2. Основная программа  
```python  
def main():
    calculator = GenotypeCalculator()
    print('g - генерация числа, i - ввод с клавиатуры')
    choice = input()
    if choice == 'g':
        calculator.generate_numbers()
    elif choice == 'i':
        calculator.input_numbers()
    else:
        print('Ошибка')
        return  
    calculator.probability()
```

---

### Пример работы программы  
**Входные данные (генерация):**  
```
Сгенерированные числа - AA: 32, Aa: 18, aa: 36  
```
**Вывод:**  
```
Вероятность: 0.72852  
```

**Входные данные (ручной ввод):**  
```
AA: 1  
Aa: 0  
aa: 1  
```
**Вывод:**  
```
Вероятность: 0.00000  
```

---

### Принципы ООП в решении  
1. **Инкапсуляция:**  
   - Данные популяции (k, m, n) и методы работы с ними объединены в классе.  
   - Логика расчёта изолирована в методе `probability()`.  

2. **Полиморфизм:**  
   - Реализованы альтернативные способы инициализации данных (генерация/ручной ввод).  

3. **Расширяемость:**  
   - Легко добавить новые типы организмов или изменить вероятности доминирования.  
   - Возможно внедрение дополнительных проверок входных данных.  

---

### Заключение  
Разработанная программа соответствует принципам ООП:  
- **Читаемость:** Чёткое разделение на методы с говорящими названиями.  
- **Гибкость:** Поддержка двух режимов ввода данных.  
- **Надёжность:** Обработка крайних случаев (например, нулевое количество пар).

лабораторная работа 2  
## **1. Цель работы**  
- Реализовать алгоритм для поиска всех позиций вхождения подстроки в строку.  
- Обеспечить удобный ввод данных и вывод результатов.  

## **2. Задачи**  
1. Написать функцию `find_substring_positions`, которая находит все стартовые позиции подстроки `t` в строке `s`.  
2. Организовать ввод строки `s` и подстроки `t` с клавиатуры.  
3. Вывести найденные позиции в удобочитаемом формате.  

## **3. Реализация**  

### **3.1. Функция `find_substring_positions`**  
```python
def find_substring_positions(s, t):
    positions = []  # Список для хранения позиций вхождения
    for i in range(len(s) - len(t) + 1):  # Проход по всем возможным стартовым позициям
        if s[i:i+len(t)] == t:  # Проверка совпадения подстроки
            positions.append(i)  # Добавление позиции в список
    return positions
```

### **3.2. Основная программа**  
```python
s = input("Введите строку s (ДНК): ")
t = input("Введите строку t (подстрока): ")
positions = find_substring_positions(s, t)
print(" ".join(map(str, positions)))  # Преобразование списка в строку с разделителем
```

### **3.3. Пример работы**  
**Входные данные:**  
```
Введите строку s (ДНК): GATATATGCATATACTT  
Введите строку t (подстрока): ATAT  
```  
**Вывод:**  
```
1 3 9
```  

## **4. Принципы программирования в решении**  

### **4.1. Простота и ясность**  
- Алгоритм использует простой перебор всех возможных позиций.  
- Код легко читается и понимается.  

### **4.2. Эффективность**  
- Время работы алгоритма — O(n*m), где n — длина строки `s`, m — длина подстроки `t`.  
- Для небольших строк (например, последовательностей ДНК) этого достаточно.  

### **4.3. Удобство ввода-вывода**  
- Ввод данных организован интерактивно.  
- Результат выводится в виде чисел, разделенных пробелами.  

## **5. Заключение**  
- Программа успешно решает поставленную задачу.  
- Алгоритм корректен и работает для стандартных случаев.  
- Код прост, понятен и может быть легко модифицирован.  

лабораторная работа 3.1
## **1. Цель работы**  
- Изучить набор данных Iris и его структуру.  
- Реализовать визуализацию данных с помощью диаграмм рассеяния.  
- Применить объектно-ориентированный подход для организации кода.  

## **2. Задачи**  
1. Загрузить набор данных Iris.  
2. Создать класс `IrisScatterPlot` для работы с данными и их визуализации.  
3. Реализовать выбор признаков для осей X и Y.  
4. Построить диаграмму рассеяния с цветовой дифференциацией по классам.  
5. Настроить оформление графика (названия осей, легенду, сетку).  

## **3. Реализация**  

### **3.1. Класс `IrisScatterPlot`**  
```python
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
import pandas as pd

class IrisScatterPlot:
    def __init__(self):
        """Инициализация с загрузкой данных Iris."""
        self.data = load_iris()
        self.df = pd.DataFrame(self.data.data, columns=self.data.feature_names)
        self.df['target'] = self.data.target

    def get_factors(self, factor_x, factor_y):
        """Получение данных для построения графика."""
        x = self.df[factor_x]
        y = self.df[factor_y]
        classes = self.df['target']
        return x, y, classes

    def plot_scatter(self, factor_x, factor_y):
        """Построение диаграммы рассеяния."""
        x, y, classes = self.get_factors(factor_x, factor_y)

        plt.figure(figsize=(10, 6))
        for class_value in classes.unique():
            plt.scatter(
                x[classes == class_value],
                y[classes == class_value],
                label=self.data.target_names[class_value]
            )

        plt.title('Диаграмма рассеяния: {} vs {}'.format(factor_x, factor_y))
        plt.xlabel(factor_x)
        plt.ylabel(factor_y)
        plt.legend(title="Классы")
        plt.grid(True)
        plt.show()
```

### **3.2. Основная программа**  
```python
if __name__ == "__main__":
    scatter_plot = IrisScatterPlot()
    scatter_plot.plot_scatter('sepal length (cm)', 'sepal width (cm)')
```

## **3. Принципы ООП и анализа данных**  

### **3.1. Инкапсуляция**  
- Данные (`data`, `df`) и методы работы с ними (`get_factors`, `plot_scatter`) объединены в классе.  

### **3.2. Гибкость**  
- Можно легко изменить признаки для осей X и Y, например:  
  ```python
  scatter_plot.plot_scatter('petal length (cm)', 'petal width (cm)')
  ```  

### **3.3. Визуализация**  
- Использована библиотека `matplotlib` для построения графиков.  
- Настройки оформления (заголовок, подписи осей, легенда, сетка) улучшают читаемость.  

## **4. Заключение**  
- Программа успешно визуализирует данные Iris с помощью диаграмм рассеяния.  
- Применен объектно-ориентированный подход для структурирования кода.  
- Решение легко расширяется для анализа других признаков или наборов данных.  

лабораторная работа 3.2

